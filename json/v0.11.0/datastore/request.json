[
  {
    "tags": [],
    "description": {
      "full": "<p>Copyright 2014 Google Inc. All Rights Reserved.</p><p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);<br />you may not use this file except in compliance with the License.<br />You may obtain a copy of the License at</p><pre><code> http://www.apache.org/licenses/LICENSE-2.0\n</code></pre><p>Unless required by applicable law or agreed to in writing, software<br />distributed under the License is distributed on an &quot;AS IS&quot; BASIS,<br />WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br />See the License for the specific language governing permissions and<br />limitations under the License.</p>",
      "summary": "<p>Copyright 2014 Google Inc. All Rights Reserved.</p>",
      "body": "<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);<br />you may not use this file except in compliance with the License.<br />You may obtain a copy of the License at</p><pre><code> http://www.apache.org/licenses/LICENSE-2.0\n</code></pre><p>Unless required by applicable law or agreed to in writing, software<br />distributed under the License is distributed on an &quot;AS IS&quot; BASIS,<br />WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br />See the License for the specific language governing permissions and<br />limitations under the License.</p>"
    },
    "isPrivate": false,
    "ignore": true
  },
  {
    "tags": [],
    "description": {
      "full": "<p>@module datastore/request</p>",
      "summary": "<p>@module datastore/request</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": true,
    "code": "'use strict';\n\nvar https = require('https');\nvar streamEvents = require('stream-events');\nvar through = require('through2');"
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>@type module:datastore/entity</p>",
      "summary": "<p>@type module:datastore/entity</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var entity = require('./entity.js');",
    "ctx": {
      "type": "declaration",
      "name": "entity",
      "value": "require('./entity.js')",
      "string": "entity"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>@type module:datastore/pb</p>",
      "summary": "<p>@type module:datastore/pb</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var pb = require('./pb.js');",
    "ctx": {
      "type": "declaration",
      "name": "pb",
      "value": "require('./pb.js')",
      "string": "pb"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>@type module:common/util</p>",
      "summary": "<p>@type module:common/util</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var util = require('../common/util.js');",
    "ctx": {
      "type": "declaration",
      "name": "util",
      "value": "require('../common/util.js')",
      "string": "util"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>@const {string} Host to send with API requests.</p>",
      "summary": "<p>@const {string} Host to send with API requests.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var GOOGLE_APIS_HOST = 'www.googleapis.com';",
    "ctx": {
      "type": "declaration",
      "name": "GOOGLE_APIS_HOST",
      "value": "'www.googleapis.com'",
      "string": "GOOGLE_APIS_HOST"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>@const {string} Non-transaction mode key.</p>",
      "summary": "<p>@const {string} Non-transaction mode key.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var MODE_NON_TRANSACTIONAL = 'NON_TRANSACTIONAL';",
    "ctx": {
      "type": "declaration",
      "name": "MODE_NON_TRANSACTIONAL",
      "value": "'NON_TRANSACTIONAL'",
      "string": "MODE_NON_TRANSACTIONAL"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>@const {string} Transaction mode key.</p>",
      "summary": "<p>@const {string} Transaction mode key.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var MODE_TRANSACTIONAL = 'TRANSACTIONAL';",
    "ctx": {
      "type": "declaration",
      "name": "MODE_TRANSACTIONAL",
      "value": "'TRANSACTIONAL'",
      "string": "MODE_TRANSACTIONAL"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": "// Inherit in Dataset and Transaction\nrequire('util').inherits(Dataset, DatastoreRequest);\nrequire('util').inherits(Transaction, DatastoreRequest);"
      }
    ],
    "description": {
      "full": "<p>Developer Documentation</p><p>Handles request logic for Datastore.</p><p>Creates requests to the Dataset endpoint. Designed to be inherited by<br />datastore.Dataset and datastore.Transaction objects.</p>",
      "summary": "<p>Developer Documentation</p>",
      "body": "<p>Handles request logic for Datastore.</p><p>Creates requests to the Dataset endpoint. Designed to be inherited by<br />datastore.Dataset and datastore.Transaction objects.</p>"
    },
    "isPrivate": false,
    "ignore": true
  },
  {
    "tags": [
      {
        "type": "constructor",
        "string": ""
      },
      {
        "type": "alias",
        "string": "module:datastore/request"
      },
      {
        "type": "mixin",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Handle logic for Datastore API operations.</p>",
      "summary": "<p>Handle logic for Datastore API operations.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function DatastoreRequest() {}",
    "ctx": {
      "type": "function",
      "name": "DatastoreRequest",
      "string": "DatastoreRequest()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Key",
          "Key[]"
        ],
        "name": "keys",
        "description": "- Datastore key object(s)."
      },
      {
        "type": "param",
        "types": [
          "function"
        ],
        "name": "callback",
        "description": "- The callback function. "
      },
      {
        "type": "example",
        "string": "//-\n// Where you see `transaction`, assume this is the context that's relevant to\n// your use, whether that be a Dataset or Transaction object.\n//-\n\n// Get a single entity.\ntransaction.get(dataset.key(['Company', 123]), function(err, entity) {});\n\n// Get multiple entities at once.\ntransaction.get([\n  dataset.key(['Company', 123]),\n  dataset.key(['Product', 'Computer'])\n], function(err, entities) {});"
      }
    ],
    "description": {
      "full": "<p>Retrieve the entities identified with the specified key(s) in the current<br />transaction. Get operations require a valid key to retrieve the<br />key-identified entity from Datastore.</p>",
      "summary": "<p>Retrieve the entities identified with the specified key(s) in the current<br />transaction. Get operations require a valid key to retrieve the<br />key-identified entity from Datastore.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "DatastoreRequest.prototype.get = function(keys, callback) {\n  var isMultipleRequest = Array.isArray(keys);\n  keys = isMultipleRequest ? keys : [keys];\n  callback = callback || util.noop;\n  var req = {\n    key: keys.map(entity.keyToKeyProto)\n  };\n  this.makeReq_('lookup', req, function(err, resp) {\n    if (err) {\n      callback(err);\n      return;\n    }\n    var found = entity.formatArray(resp.found);\n    if (isMultipleRequest && resp.deferred && resp.deferred.length) {\n      // There may be more results. Call `.get` again, and append the results.\n      this.get(\n          resp.deferred.map(entity.keyFromKeyProto), function(err, entities) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (resp) {\n          found = (found || []).concat(entities);\n        }\n        callback(null, found);\n      });\n      return;\n    }\n    callback(null, isMultipleRequest ? found : found[0]);\n  }.bind(this));\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "get",
      "string": "DatastoreRequest.prototype.get()"
    }
  },
  {
    "tags": [
      {
        "type": "borrows",
        "otherMemberName": "{module:datastore/transaction#save}",
        "thisMemberName": "save "
      },
      {
        "type": "param",
        "types": [
          "object",
          "object[]"
        ],
        "name": "entities",
        "description": "- Datastore key object(s)."
      },
      {
        "type": "param",
        "types": [
          "Key"
        ],
        "name": "entities.key",
        "description": "- Datastore key object."
      },
      {
        "type": "param",
        "types": [
          "object",
          "object[]"
        ],
        "name": "entities.data",
        "description": "- Data to save with the provided key.     If you provide an array of objects, you must use the explicit syntax:\n    `name` for the name of the property and `value` for its value. You may\n    also specify an `excludeFromIndexes` property, set to `true` or `false`."
      },
      {
        "type": "param",
        "types": [
          "function"
        ],
        "name": "callback",
        "description": "- The callback function. "
      },
      {
        "type": "example",
        "string": "//-\n// Where you see `transaction`, assume this is the context that's relevant to\n// your use, whether that be a Dataset or a Transaction object.\n//-\n\n// Save a single entity.\ntransaction.save({\n  key: dataset.key('Company'),\n  data: {\n    rating: '10'\n  }\n}, function(err, key) {\n  // Because we gave an incomplete key as an argument, `key` will be\n  // populated with the complete, generated key.\n});\n\n// To specify an `excludeFromIndexes` value for a Datastore entity, pass in\n// an array for the key's data. The above example would then look like:\ntransaction.save({\n  key: dataset.key('Company'),\n  data: [\n    {\n      name: 'rating',\n      value: '10',\n      excludeFromIndexes: false\n    }\n  ]\n}, function(err, key) {});\n\n// Save multiple entities at once.\ntransaction.save([\n  {\n    key: dataset.key(['Company', 123]),\n    data: {\n      HQ: 'Dallas, TX'\n    }\n  },\n  {\n    key: dataset.key(['Product', 'Computer']),\n    data: {\n      vendor: 'Dell'\n    }\n  }\n], function(err, keys) {});"
      }
    ],
    "description": {
      "full": "<p>Insert or update the specified object(s) in the current transaction. If a key<br />is incomplete, its associated object is inserted and its generated identifier<br />is returned to the callback.</p><p>This method will determine the correct Datastore method to execute (<code>upsert</code>,<br /><code>insert</code>, <code>update</code>, and <code>insertAutoId</code>) by using the key(s) provided. For<br />example, if you provide an incomplete key (one without an ID), the request<br />will create a new entity and have its ID automatically assigned. If you<br />provide a complete key, the entity will be updated with the data specified.</p><p>By default, all properties are indexed. To prevent a property from being<br />included in <em>all</em> indexes, you must supply an entity&#39;s <code>data</code> property as an<br />array. See below for an example.</p>",
      "summary": "<p>Insert or update the specified object(s) in the current transaction. If a key<br />is incomplete, its associated object is inserted and its generated identifier<br />is returned to the callback.</p>",
      "body": "<p>This method will determine the correct Datastore method to execute (<code>upsert</code>,<br /><code>insert</code>, <code>update</code>, and <code>insertAutoId</code>) by using the key(s) provided. For<br />example, if you provide an incomplete key (one without an ID), the request<br />will create a new entity and have its ID automatically assigned. If you<br />provide a complete key, the entity will be updated with the data specified.</p><p>By default, all properties are indexed. To prevent a property from being<br />included in <em>all</em> indexes, you must supply an entity&#39;s <code>data</code> property as an<br />array. See below for an example.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "DatastoreRequest.prototype.save = function(entities, callback) {\n  var isMultipleRequest = Array.isArray(entities);\n  entities = isMultipleRequest ? entities : [entities];\n  var insertIndexes = [];\n  var keys = entities.map(function(entityObject) {\n    return entityObject.key;\n  });\n  var req = {\n    mutation: entities.reduce(function(acc, entityObject, index) {\n      var ent = {};\n      if (Array.isArray(entityObject.data)) {\n        ent.property = entityObject.data.map(function(data) {\n          data.value = entity.valueToProperty(data.value);\n          if (util.is(data.excludeFromIndexes, 'boolean')) {\n            data.value.indexed = !data.excludeFromIndexes;\n            delete data.excludeFromIndexes;\n          }\n          return data;\n        });\n      } else {\n        ent = entity.entityToEntityProto(entityObject.data);\n      }\n      ent.key = entity.keyToKeyProto(entityObject.key);\n      if (entity.isKeyComplete(entityObject.key)) {\n        acc.upsert.push(ent);\n      } else {\n        insertIndexes.push(index);\n        acc.insert_auto_id.push(ent);\n      }\n      return acc;\n    }.bind(this), { upsert: [], insert_auto_id: [] })\n  };\n  this.makeReq_('commit', req, function(err, resp) {\n    if (err || !resp) {\n      callback(err);\n      return;\n    }\n    if (this.id) {\n      this.isFinalized = true;\n    }\n    var autoInserted = (resp.mutation_result.insert_auto_id_key || []);\n    autoInserted.forEach(function(key, index) {\n      keys[insertIndexes[index]] = entity.keyFromKeyProto(key);\n    });\n    callback(null, isMultipleRequest ? keys : keys[0]);\n  }.bind(this));\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "save",
      "string": "DatastoreRequest.prototype.save()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Key",
          "Key[]"
        ],
        "name": "key",
        "description": "- Datastore key object(s)."
      },
      {
        "type": "param",
        "types": [
          "function"
        ],
        "name": "callback",
        "description": "- The callback function. "
      },
      {
        "type": "example",
        "string": "//-\n// Where you see `transaction`, assume this is the context that's relevant to\n// your use, whether that be a Dataset or a Transaction object.\n//-\n\n// Delete a single entity.\ntransaction.delete(dataset.key(['Company', 123]), function(err) {});\n\n// Delete multiple entities at once.\ntransaction.delete([\n  dataset.key(['Company', 123]),\n  dataset.key(['Product', 'Computer'])\n], function(err) {});"
      }
    ],
    "description": {
      "full": "<p>Delete all entities identified with the specified key(s) in the current<br />transaction.</p>",
      "summary": "<p>Delete all entities identified with the specified key(s) in the current<br />transaction.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "DatastoreRequest.prototype.delete = function(keys, callback) {\n  var isMultipleRequest = Array.isArray(keys);\n  keys = isMultipleRequest ? keys : [keys];\n  callback = callback || util.noop;\n  var req = {\n    mutation: {\n      delete: keys.map(entity.keyToKeyProto)\n    }\n  };\n  this.makeReq_('commit', req, function(err) {\n    if (!err && this.id) {\n      this.isFinalized = true;\n    }\n    callback.apply(null, util.toArray(arguments));\n  }.bind(this));\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "delete",
      "string": "DatastoreRequest.prototype.delete()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "module:datastore",
          "query"
        ],
        "name": "q",
        "description": "- Query object."
      },
      {
        "type": "param",
        "types": [
          "function="
        ],
        "name": "callback",
        "description": "- The callback function. If omitted, a readable     stream instance is returned.\n"
      },
      {
        "type": "example",
        "string": "//-\n// Where you see `transaction`, assume this is the context that's relevant to\n// your use, whether that be a Dataset or a Transaction object.\n//-\n\n// Retrieve 5 companies.\ntransaction.runQuery(queryObject, function(err, entities, endCursor) {\n  // Use `endCursor` as the starting cursor for your next query.\n  var nextQuery = queryObject.start(endCursor);\n  transaction.runQuery(nextQuery, function(err, entities, endCursor) {});\n});\n\n//-\n// If you omit the callback, runQuery will automatically call subsequent\n// queries until no results remain. Entity objects will be pushed as they are\n// found.\n//-\ntransaction.runQuery(queryObject)\n  .on('data', function (entity) {});"
      }
    ],
    "description": {
      "full": "<p>Datastore allows you to query entities by kind, filter them by property<br />filters, and sort them by a property name. Projection and pagination are also<br />supported.</p><p>If you provide a callback, the query is run, and the results are returned as<br />the second argument to your callback. A third argument will also exist, which<br />is the <code>endCursor</code> of the previously-run query. You can use this to extend<br />the query you just ran to see if more results exist.</p><p>You may also omit the callback to this function to trigger streaming mode.</p><p>See below for examples of both approaches.</p>",
      "summary": "<p>Datastore allows you to query entities by kind, filter them by property<br />filters, and sort them by a property name. Projection and pagination are also<br />supported.</p>",
      "body": "<p>If you provide a callback, the query is run, and the results are returned as<br />the second argument to your callback. A third argument will also exist, which<br />is the <code>endCursor</code> of the previously-run query. You can use this to extend<br />the query you just ran to see if more results exist.</p><p>You may also omit the callback to this function to trigger streaming mode.</p><p>See below for examples of both approaches.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "DatastoreRequest.prototype.runQuery = function(q, callback) {\n  var that = this;\n  var stream;\n  var resultsToSend = q.limitVal;\n\n  var req = {\n    read_options: {},\n    query: entity.queryToQueryProto(q)\n  };\n\n  if (q.namespace) {\n    req.partition_id = {\n      namespace: q.namespace\n    };\n  }\n\n  if (!util.is(callback, 'function')) {\n    stream = streamEvents(through.obj());\n    stream.once('reading', runQuery);\n    return stream;\n  } else {\n    runQuery();\n  }\n\n  function runQuery() {\n    that.makeReq_('runQuery', req, function(err, resp) {\n      if (err) {\n        if (stream) {\n          stream.emit('error', err);\n          stream.end();\n        } else {\n          callback(err);\n        }\n        return;\n      }\n\n      var entities = entity.formatArray(resp.batch.entity_result);\n\n      var cursor = '';\n      if (resp.batch.end_cursor) {\n        cursor = resp.batch.end_cursor.toBase64();\n      }\n\n      if (!stream) {\n        callback(null, entities, cursor);\n        return;\n      }\n\n      if (!cursor || entities.length === 0) {\n        stream.end();\n        return;\n      }\n\n      var result;\n      while ((result = entities.shift()) && resultsToSend !== 0) {\n        stream.push(result);\n        resultsToSend--;\n      }\n\n      if (resultsToSend === 0) {\n        stream.end();\n        return;\n      }\n\n      req.query = entity.queryToQueryProto(q.start(cursor).offset(0));\n      runQuery();\n    });\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "runQuery",
      "string": "DatastoreRequest.prototype.runQuery()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Key"
        ],
        "name": "incompleteKey",
        "description": "- The key object to complete."
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "n",
        "description": "- How many IDs to generate."
      },
      {
        "type": "param",
        "types": [
          "function"
        ],
        "name": "callback",
        "description": "- The callback function. "
      },
      {
        "type": "example",
        "string": "//-\n// Where you see `transaction`, assume this is the context that's relevant to\n// your use, whether that be a Dataset or a Transaction object.\n//-\n\n// The following call will create 100 new IDs from the Company kind, which\n// exists under the default namespace.\ntransaction.allocateIds(incompleteKey, 100, function(err, keys) {});\n\n// You may prefer to create IDs from a non-default namespace by providing an\n// incomplete key with a namespace. Similar to the previous example, the call\n// below will create 100 new IDs, but from the Company kind that exists under\n// the \"ns-test\" namespace.\nvar incompleteKey = dataset.key({\n  namespace: 'ns-test',\n  path: ['Company']\n});\ntransaction.allocateIds(incompleteKey, 100, function(err, keys) {});"
      }
    ],
    "description": {
      "full": "<p>Generate IDs without creating entities.</p>",
      "summary": "<p>Generate IDs without creating entities.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "DatastoreRequest.prototype.allocateIds = function(incompleteKey, n, callback) {\n  if (entity.isKeyComplete(incompleteKey)) {\n    throw new Error('An incomplete key should be provided.');\n  }\n  var incompleteKeys = [];\n  for (var i = 0; i < n; i++) {\n    incompleteKeys.push(entity.keyToKeyProto(incompleteKey));\n  }\n  var req = {\n    key: incompleteKeys\n  };\n  this.makeReq_('allocateIds', req, function(err, resp) {\n    if (err) {\n      callback(err);\n      return;\n    }\n    var keys = [];\n    (resp.key || []).forEach(function(k) {\n      keys.push(entity.keyFromKeyProto(k));\n    });\n    callback(null, keys);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "allocateIds",
      "string": "DatastoreRequest.prototype.allocateIds()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "string"
        ],
        "name": "method",
        "description": "- Datastore action (allocateIds, commit, etc.)."
      },
      {
        "type": "param",
        "types": [
          "object="
        ],
        "name": "body",
        "description": "- Request configuration object."
      },
      {
        "type": "param",
        "types": [
          "function"
        ],
        "name": "callback",
        "description": "- The callback function. "
      },
      {
        "type": "private",
        "visibility": "private"
      },
      {
        "type": "example",
        "string": "var deleteRequest = {\n  mutation: {\n    delete: [] // datastore key objects.\n  }\n};\ntransaction.makeReq('commit', deleteRequest, function(err) {});"
      }
    ],
    "description": {
      "full": "<p>Make a request to the API endpoint. Properties to indicate a transactional or<br />non-transactional operation are added automatically.</p>",
      "summary": "<p>Make a request to the API endpoint. Properties to indicate a transactional or<br />non-transactional operation are added automatically.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "DatastoreRequest.prototype.makeReq_ = function(method, body, callback) {\n  // TODO: Handle non-HTTP 200 cases.\n  if (!callback) {\n    callback = body;\n    body = {};\n  }\n  callback = callback || util.noop;\n\n  // Set properties to indicate if we're in a transaction or not.\n  if (method === 'commit') {\n    if (this.id) {\n      body.mode = MODE_TRANSACTIONAL;\n      body.transaction = this.id;\n    } else {\n      body.mode = MODE_NON_TRANSACTIONAL;\n    }\n  }\n\n  if (method === 'lookup' && this.id) {\n    body.read_options = body.read_options || {};\n    body.read_options.transaction = this.id;\n  }\n\n  var pbKey = method[0].toUpperCase() + method.substr(1);\n  var pbRequest = new pb[pbKey + 'Request'](body).toBuffer();\n  var pbResponse = pb[pbKey + 'Response'];\n\n  var reqOpts = {\n    method: 'POST',\n    host: GOOGLE_APIS_HOST,\n    path: '/datastore/v1beta2/datasets/' + this.projectId + '/' + method,\n    headers: {\n      'Content-Type': 'application/x-protobuf'\n    }\n  };\n\n  this.makeAuthorizedRequest_(reqOpts, {\n    onAuthorized: function(err, authorizedReqOpts) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      var remoteStream = https.request(authorizedReqOpts, function(resp) {\n        var buffer = new Buffer('');\n        resp.on('data', function(chunk) {\n          buffer = Buffer.concat([buffer, chunk]);\n        });\n        resp.on('end', function() {\n          util.handleResp(null, resp, buffer.toString(), function(err) {\n            if (err) {\n              callback(err);\n              return;\n            }\n            callback(null, pbResponse.decode(buffer));\n          });\n        });\n      });\n      remoteStream.on('error', callback);\n      remoteStream.write(pbRequest);\n      remoteStream.end();\n    }\n  });\n};\n\nmodule.exports = DatastoreRequest;",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "makeReq_",
      "string": "DatastoreRequest.prototype.makeReq_()"
    }
  }
]